{"version":3,"sources":["parseLogBoxLog.js"],"names":["BABEL_TRANSFORM_ERROR_FORMAT","BABEL_CODE_FRAME_ERROR_FORMAT","SUBSTITUTION","UTFSequence","BOM","parseCategory","args","categoryParts","contentParts","substitutionOffsets","remaining","formatString","String","shift","formatStringParts","split","substitutionCount","length","substitutions","splice","categoryString","contentString","substitutionIndex","formatStringPart","substitution","push","offset","remainingArgs","map","arg","category","join","message","content","parseComponentStack","s","match","slice","fileName","row","location","column","parseInt","filter","Boolean","parseLogBoxException","error","originalMessage","babelTransformError","codeFrame","level","stack","isComponentError","componentStack","babelCodeFrameError","isFatal","parseLogBoxLog","argsWithoutComponentStack","lastArg","test","exec"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport UTFSequence from '../../UTFSequence';\nimport stringifySafe from '../../Utilities/stringifySafe';\nimport type {ExceptionData} from '../../Core/NativeExceptionsManager';\nimport type {LogBoxLogData} from './LogBoxLog';\n\nconst BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nconst BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:.*): (.*): ([\\s\\S]+?)\\n([ >]{2}[\\d\\s]+ \\|[\\s\\S]+|\\u{001b}[\\s\\S]+)/u;\n\nexport type ExtendedExceptionData = ExceptionData & {\n  isComponentError: boolean,\n  ...\n};\nexport type Category = string;\nexport type CodeFrame = $ReadOnly<{|\n  content: string,\n  location: ?{\n    row: number,\n    column: number,\n    ...\n  },\n  fileName: string,\n|}>;\nexport type Message = $ReadOnly<{|\n  content: string,\n  substitutions: $ReadOnlyArray<\n    $ReadOnly<{|\n      length: number,\n      offset: number,\n    |}>,\n  >,\n|}>;\n\nexport type ComponentStack = $ReadOnlyArray<CodeFrame>;\n\nconst SUBSTITUTION = UTFSequence.BOM + '%s';\n\nexport function parseCategory(\n  args: $ReadOnlyArray<mixed>,\n): $ReadOnly<{|\n  category: Category,\n  message: Message,\n|}> {\n  const categoryParts = [];\n  const contentParts = [];\n  const substitutionOffsets = [];\n\n  const remaining = [...args];\n  if (typeof remaining[0] === 'string') {\n    const formatString = String(remaining.shift());\n    const formatStringParts = formatString.split('%s');\n    const substitutionCount = formatStringParts.length - 1;\n    const substitutions = remaining.splice(0, substitutionCount);\n\n    let categoryString = '';\n    let contentString = '';\n\n    let substitutionIndex = 0;\n    for (const formatStringPart of formatStringParts) {\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          // Don't stringify a string type.\n          // It adds quotation mark wrappers around the string,\n          // which causes the LogBox to look odd.\n          const substitution =\n            typeof substitutions[substitutionIndex] === 'string'\n              ? substitutions[substitutionIndex]\n              : stringifySafe(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length,\n          });\n\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length,\n          });\n\n          categoryString += '%s';\n          contentString += '%s';\n        }\n\n        substitutionIndex++;\n      }\n    }\n\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n\n  const remainingArgs = remaining.map(arg => {\n    // Don't stringify a string type.\n    // It adds quotation mark wrappers around the string,\n    // which causes the LogBox to look odd.\n    return typeof arg === 'string' ? arg : stringifySafe(arg);\n  });\n  categoryParts.push(...remainingArgs);\n  contentParts.push(...remainingArgs);\n\n  return {\n    category: categoryParts.join(' '),\n    message: {\n      content: contentParts.join(' '),\n      substitutions: substitutionOffsets,\n    },\n  };\n}\n\nexport function parseComponentStack(message: string): ComponentStack {\n  return message\n    .split(/\\n {4}in /g)\n    .map(s => {\n      if (!s) {\n        return null;\n      }\n      const match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\n      if (!match) {\n        return null;\n      }\n\n      let [content, fileName, row] = match.slice(1);\n      return {\n        content,\n        fileName,\n        location: {column: -1, row: parseInt(row, 10)},\n      };\n    })\n    .filter(Boolean);\n}\n\nexport function parseLogBoxException(\n  error: ExtendedExceptionData,\n): LogBoxLogData {\n  const message =\n    error.originalMessage != null ? error.originalMessage : 'Unknown';\n\n  const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\n  if (babelTransformError) {\n    // Transform errors are thrown from inside the Babel transformer.\n    const [\n      fileName,\n      content,\n      row,\n      column,\n      codeFrame,\n    ] = babelTransformError.slice(1);\n\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n    };\n  }\n\n  const babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\n\n  if (babelCodeFrameError) {\n    // Codeframe errors are thrown from any use of buildCodeFrameError.\n    const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: null, // We are not given the location.\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${1}-${1}`,\n    };\n  }\n\n  const level = message.match(/^TransformError /)\n    ? 'syntax'\n    : error.isFatal || error.isComponentError\n    ? 'fatal'\n    : 'error';\n\n  return {\n    level: level,\n    stack: error.stack,\n    isComponentError: error.isComponentError,\n    componentStack:\n      error.componentStack != null\n        ? parseComponentStack(error.componentStack)\n        : [],\n    ...parseCategory([message]),\n  };\n}\n\nexport function parseLogBoxLog(\n  args: $ReadOnlyArray<mixed>,\n): {|\n  componentStack: ComponentStack,\n  category: Category,\n  message: Message,\n|} {\n  const message = args[0];\n  let argsWithoutComponentStack = [];\n  let componentStack = [];\n\n  // Extract component stack from warnings like \"Some warning%s\".\n  if (\n    typeof message === 'string' &&\n    message.slice(-2) === '%s' &&\n    args.length > 0\n  ) {\n    const lastArg = args[args.length - 1];\n    // Does it look like React component stack? \"   in ...\"\n    if (typeof lastArg === 'string' && /\\s{4}in/.test(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      componentStack = parseComponentStack(lastArg);\n    }\n  }\n\n  if (componentStack.length === 0) {\n    // Try finding the component stack elsewhere.\n    for (const arg of args) {\n      if (typeof arg === 'string' && /^\\n {4}in/.exec(arg)) {\n        componentStack = parseComponentStack(arg);\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n\n  return {\n    ...parseCategory(argsWithoutComponentStack),\n    componentStack,\n  };\n}\n"]}